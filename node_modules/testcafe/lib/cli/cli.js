"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const runtime_1 = require("../errors/runtime");
const types_1 = require("../errors/types");
const argument_parser_1 = __importDefault(require("./argument-parser"));
const termination_handler_1 = __importDefault(require("./termination-handler"));
const log_1 = __importDefault(require("./log"));
const remotes_wizard_1 = __importDefault(require("./remotes-wizard"));
const correct_browsers_and_sources_1 = __importDefault(require("./correct-browsers-and-sources"));
const __1 = __importDefault(require("../"));
const marketing = __importStar(require("../marketing"));
const is_ci_1 = __importDefault(require("is-ci"));
// NOTE: Load the provider pool lazily to reduce startup time
const lazyRequire = require('import-lazy')(require);
const browserProviderPool = lazyRequire('../browser/provider/pool');
const NOT_PARSABLE_REPORTERS = ['spec', 'list', 'minimal'];
let showMessageOnExit = true;
let exitMessageShown = false;
let exiting = false;
function exitHandler(terminationLevel) {
    if (showMessageOnExit && !exitMessageShown) {
        exitMessageShown = true;
        log_1.default.write('Stopping TestCafe...');
        process.on('exit', () => log_1.default.hideSpinner(true));
    }
    if (exiting || terminationLevel < 2)
        return;
    exiting = true;
    exit(0);
}
function exit(code) {
    log_1.default.hideSpinner(true);
    // NOTE: give a process time to flush the output.
    // It's necessary in some environments.
    setTimeout(() => process.exit(code), 0);
}
function error(err) {
    log_1.default.hideSpinner();
    let message = null;
    if (err instanceof runtime_1.GeneralError)
        message = err.message;
    else if (err instanceof runtime_1.APIError)
        message = err.coloredStack;
    else
        message = err.stack;
    log_1.default.write(chalk_1.default.red('ERROR ') + message + '\n');
    log_1.default.write(chalk_1.default.gray('Type "testcafe -h" for help.'));
    exit(1);
}
function shouldShowMarketingMessage(reporterPlugings) {
    if (is_ci_1.default)
        return false;
    const stdoutReporterPlugin = reporterPlugings.find(plugin => plugin.outStream === process.stdout || !plugin.outStream);
    return stdoutReporterPlugin && NOT_PARSABLE_REPORTERS.includes(stdoutReporterPlugin.plugin.name);
}
async function runTests(argParser) {
    const opts = argParser.opts;
    const port1 = opts.ports && opts.ports[0];
    const port2 = opts.ports && opts.ports[1];
    const proxy = opts.proxy;
    const proxyBypass = opts.proxyBypass;
    log_1.default.showSpinner();
    const testCafe = await __1.default(opts.hostname, port1, port2, opts.ssl, opts.dev);
    const correctedBrowsersAndSources = await correct_browsers_and_sources_1.default(argParser, testCafe.configuration);
    const automatedBrowsers = correctedBrowsersAndSources.browsers;
    const remoteBrowsers = await remotes_wizard_1.default(testCafe, argParser.remoteCount, opts.qrCode);
    const browsers = automatedBrowsers.concat(remoteBrowsers);
    const sources = correctedBrowsersAndSources.sources;
    const runner = opts.live ? testCafe.createLiveModeRunner() : testCafe.createRunner();
    let failed = 0;
    runner.isCli = true;
    runner
        .useProxy(proxy, proxyBypass)
        .src(sources)
        .tsConfigPath(argParser.opts.tsConfigPath)
        .browsers(browsers)
        .reporter(argParser.opts.reporter)
        .concurrency(argParser.opts.concurrency)
        .filter(argParser.filter)
        .video(opts.video, opts.videoOptions, opts.videoEncodingOptions)
        .screenshots(opts.screenshots, opts.screenshotsOnFails, opts.screenshotPathPattern)
        .startApp(opts.app, opts.appInitDelay)
        .clientScripts(argParser.opts.clientScripts);
    runner.once('done-bootstrapping', () => log_1.default.hideSpinner());
    try {
        failed = await runner.run(opts);
        if (shouldShowMarketingMessage(runner.reporterPlugings))
            await marketing.showMessageWithLinkToTestCafeStudio();
    }
    finally {
        showMessageOnExit = false;
        await testCafe.close();
    }
    exit(failed);
}
async function listBrowsers(providerName = 'locally-installed') {
    const provider = await browserProviderPool.getProvider(providerName);
    if (!provider)
        throw new runtime_1.GeneralError(types_1.RUNTIME_ERRORS.browserProviderNotFound, providerName);
    if (provider.isMultiBrowser) {
        const browserNames = await provider.getBrowserList();
        await browserProviderPool.dispose();
        if (providerName === 'locally-installed')
            console.log(browserNames.join('\n'));
        else
            console.log(browserNames.map(browserName => `"${providerName}:${browserName}"`).join('\n'));
    }
    else
        console.log(`"${providerName}"`);
    exit(0);
}
(async function cli() {
    const terminationHandler = new termination_handler_1.default();
    terminationHandler.on(termination_handler_1.default.TERMINATION_LEVEL_INCREASED_EVENT, exitHandler);
    try {
        const argParser = new argument_parser_1.default();
        await argParser.parse(process.argv);
        if (argParser.opts.listBrowsers)
            await listBrowsers(argParser.opts.providerName);
        else
            await runTests(argParser);
    }
    catch (err) {
        showMessageOnExit = false;
        error(err);
    }
})();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xpLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NsaS9jbGkuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsa0RBQTBCO0FBQzFCLCtDQUEyRDtBQUMzRCwyQ0FBaUQ7QUFDakQsd0VBQWtEO0FBQ2xELGdGQUF1RDtBQUN2RCxnREFBd0I7QUFDeEIsc0VBQTZDO0FBQzdDLGtHQUF1RTtBQUN2RSw0Q0FBaUM7QUFDakMsd0RBQTBDO0FBQzFDLGtEQUF5QjtBQUV6Qiw2REFBNkQ7QUFDN0QsTUFBTSxXQUFXLEdBQVcsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzVELE1BQU0sbUJBQW1CLEdBQUcsV0FBVyxDQUFDLDBCQUEwQixDQUFDLENBQUM7QUFFcEUsTUFBTSxzQkFBc0IsR0FBRyxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUM7QUFFM0QsSUFBSSxpQkFBaUIsR0FBRyxJQUFJLENBQUM7QUFDN0IsSUFBSSxnQkFBZ0IsR0FBSSxLQUFLLENBQUM7QUFDOUIsSUFBSSxPQUFPLEdBQWEsS0FBSyxDQUFDO0FBRTlCLFNBQVMsV0FBVyxDQUFFLGdCQUFnQjtJQUNsQyxJQUFJLGlCQUFpQixJQUFJLENBQUMsZ0JBQWdCLEVBQUU7UUFDeEMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDO1FBRXhCLGFBQUcsQ0FBQyxLQUFLLENBQUMsc0JBQXNCLENBQUMsQ0FBQztRQUVsQyxPQUFPLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxHQUFHLEVBQUUsQ0FBQyxhQUFHLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7S0FDbkQ7SUFFRCxJQUFJLE9BQU8sSUFBSSxnQkFBZ0IsR0FBRyxDQUFDO1FBQy9CLE9BQU87SUFFWCxPQUFPLEdBQUcsSUFBSSxDQUFDO0lBRWYsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ1osQ0FBQztBQUVELFNBQVMs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LENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXBDLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxZQUFZO1lBQzNCLE1BQU0sWUFBWSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7O1lBRWhELE1BQU0sUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0tBQ2pDO0lBQ0QsT0FBTyxHQUFHLEVBQUU7UUFDUixpQkFBaUIsR0FBRyxLQUFLLENBQUM7UUFDMUIsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBQ2Q7QUFDTCxDQUFDLENBQUMsRUFBRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNoYWxrIGZyb20gJ2NoYWxrJztcbmltcG9ydCB7IEdlbmVyYWxFcnJvciwgQVBJRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvcnVudGltZSc7XG5pbXBvcnQgeyBSVU5USU1FX0VSUk9SUyB9IGZyb20gJy4uL2Vycm9ycy90eXBlcyc7XG5pbXBvcnQgQ2xpQXJndW1lbnRQYXJzZXIgZnJvbSAnLi9hcmd1bWVudC1wYXJzZXInO1xuaW1wb3J0IFRlcm1pbmF0aW9uSGFuZGxlciBmcm9tICcuL3Rlcm1pbmF0aW9uLWhhbmRsZXInO1xuaW1wb3J0IGxvZyBmcm9tICcuL2xvZyc7XG5pbXBvcnQgcmVtb3Rlc1dpemFyZCBmcm9tICcuL3JlbW90ZXMtd2l6YXJkJztcbmltcG9ydCBjb3JyZWN0QnJvd3NlcnNBbmRTb3VyY2VzIGZyb20gJy4vY29ycmVjdC1icm93c2Vycy1hbmQtc291cmNlcyc7XG5pbXBvcnQgY3JlYXRlVGVzdENhZmUgZnJvbSAnLi4vJztcbmltcG9ydCAqIGFzIG1hcmtldGluZyBmcm9tICcuLi9tYXJrZXRpbmcnO1xuaW1wb3J0IGlzQ0kgZnJvbSAnaXMtY2knO1xuXG4vLyBOT1RFOiBMb2FkIHRoZSBwcm92aWRlciBwb29sIGxhemlseSB0byByZWR1Y2Ugc3RhcnR1cCB0aW1lXG5jb25zdCBsYXp5UmVxdWlyZSAgICAgICAgID0gcmVxdWlyZSgnaW1wb3J0LWxhenknKShyZXF1aXJlKTtcbmNvbnN0IGJyb3dzZXJQcm92aWRlclBvb2wgPSBsYXp5UmVxdWlyZSgnLi4vYnJvd3Nlci9wcm92aWRlci9wb29sJyk7XG5cbmNvbnN0IE5PVF9QQVJTQUJMRV9SRVBPUlRFUlMgPSBbJ3NwZWMnLCAnbGlzdCcsICdtaW5pbWFsJ107XG5cbmxldCBzaG93TWVzc2FnZU9uRXhpdCA9IHRydWU7XG5sZXQgZXhpdE1lc3NhZ2VTaG93biAgPSBmYWxzZTtcbmxldCBleGl0aW5nICAgICAgICAgICA9IGZhbHNlO1xuXG5mdW5jdGlvbiBleGl0SGFuZGxlciAodGVybWluYXRpb25MZXZlbCkge1xuICAgIGlmIChzaG93TWVzc2FnZU9uRXhpdCAmJiAhZXhpdE1lc3NhZ2VTaG93bikge1xuICAgICAgICBleGl0TWVzc2FnZVNob3duID0gdHJ1ZTtcblxuICAgICAgICBsb2cud3JpdGUoJ1N0b3BwaW5nIFRlc3RDYWZlLi4uJyk7XG5cbiAgICAgICAgcHJvY2Vzcy5vbignZXhpdCcsICgpID0+IGxvZy5oaWRlU3Bpbm5lcih0cnVlKSk7XG4gICAgfVxuXG4gICAgaWYgKGV4aXRpbmcgfHwgdGVybWluYXRpb25MZXZlbCA8IDIpXG4gICAgICAgIHJldHVybjtcblxuICAgIGV4aXRpbmcgPSB0cnVlO1xuXG4gICAgZXhpdCgwKTtcbn1cblxuZnVuY3Rpb24gZXhpdCAoY29kZSkge1xuICAgIGxvZy5oaWRlU3Bpbm5lcih0cnVlKTtcblxuICAgIC8vIE5PVEU6IGdpdmUgYSBwcm9jZXNzIHRpbWUgdG8gZmx1c2ggdGhlIG91dHB1dC5cbiAgICAvLyBJdCdzIG5lY2Vzc2FyeSBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHByb2Nlc3MuZXhpdChjb2RlKSwgMCk7XG59XG5cbmZ1bmN0aW9uIGVycm9yIChlcnIpIHtcbiAgICBsb2cuaGlkZVNwaW5uZXIoKTtcblxuICAgIGxldCBtZXNzYWdlID0gbnVsbDtcblxuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBHZW5lcmFsRXJyb3IpXG4gICAgICAgIG1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcblxuICAgIGVsc2UgaWYgKGVyciBpbnN0YW5jZW9mIEFQSUVycm9yKVxuICAgICAgICBtZXNzYWdlID0gZXJyLmNvbG9yZWRTdGFjaztcblxuICAgIGVsc2VcbiAgICAgICAgbWVzc2FnZSA9IGVyci5zdGFjaztcblxuICAgIGxvZy53cml0ZShjaGFsay5yZWQoJ0VSUk9SICcpICsgbWVzc2FnZSArICdcXG4nKTtcbiAgICBsb2cud3JpdGUoY2hhbGsuZ3JheSgnVHlwZSBcInRlc3RjYWZlIC1oXCIgZm9yIGhlbHAuJykpO1xuXG4gICAgZXhpdCgxKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkU2hvd01hcmtldGluZ01lc3NhZ2UgKHJlcG9ydGVyUGx1Z2luZ3MpIHtcbiAgICBpZiAoaXNDSSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgY29uc3Qgc3Rkb3V0UmVwb3J0ZXJQbHVnaW4gPSByZXBvcnRlclBsdWdpbmdzLmZpbmQocGx1Z2luID0+IHBsdWdpbi5vdXRTdHJlYW0gPT09IHByb2Nlc3Muc3Rkb3V0IHx8ICFwbHVnaW4ub3V0U3RyZWFtKTtcblxuICAgIHJldHVybiBzdGRvdXRSZXBvcnRlclBsdWdpbiAmJiBOT1RfUEFSU0FCTEVfUkVQT1JURVJTLmluY2x1ZGVzKHN0ZG91dFJlcG9ydGVyUGx1Z2luLnBsdWdpbi5uYW1lKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcnVuVGVzdHMgKGFyZ1BhcnNlcikge1xuICAgIGNvbnN0IG9wdHMgICAgICAgICAgICAgID0gYXJnUGFyc2VyLm9wdHM7XG4gICAgY29uc3QgcG9ydDEgICAgICAgICAgICAgPSBvcHRzLnBvcnRzICYmIG9wdHMucG9ydHNbMF07XG4gICAgY29uc3QgcG9ydDIgICAgICAgICAgICAgPSBvcHRzLnBvcnRzICYmIG9wdHMucG9ydHNbMV07XG4gICAgY29uc3QgcHJveHkgICAgICAgICAgICAgPSBvcHRzLnByb3h5O1xuICAgIGNvbnN0IHByb3h5QnlwYXNzICAgICAgID0gb3B0cy5wcm94eUJ5cGFzcztcblxuICAgIGxvZy5zaG93U3Bpbm5lcigpO1xuXG4gICAgY29uc3QgdGVzdENhZmUgPSBhd2FpdCBjcmVhdGVUZXN0Q2FmZShvcHRzLmhvc3RuYW1lLCBwb3J0MSwgcG9ydDIsIG9wdHMuc3NsLCBvcHRzLmRldik7XG5cbiAgICBjb25zdCBjb3JyZWN0ZWRCcm93c2Vyc0FuZFNvdXJjZXMgPSBhd2FpdCBjb3JyZWN0QnJvd3NlcnNBbmRTb3VyY2VzKGFyZ1BhcnNlciwgdGVzdENhZmUuY29uZmlndXJhdGlvbik7XG4gICAgY29uc3QgYXV0b21hdGVkQnJvd3NlcnMgICAgICAgICAgID0gY29ycmVjdGVkQnJvd3NlcnNBbmRTb3VyY2VzLmJyb3dzZXJzO1xuICAgIGNvbnN0IHJlbW90ZUJyb3dzZXJzICAgICAgICAgICAgICA9IGF3YWl0IHJlbW90ZXNXaXphcmQodGVzdENhZmUsIGFyZ1BhcnNlci5yZW1vdGVDb3VudCwgb3B0cy5xckNvZGUpO1xuICAgIGNvbnN0IGJyb3dzZXJzICAgICAgICAgICAgICAgICAgICA9IGF1dG9tYXRlZEJyb3dzZXJzLmNvbmNhdChyZW1vdGVCcm93c2Vycyk7XG4gICAgY29uc3Qgc291cmNlcyAgICAgICAgICAgICAgICAgICAgID0gY29ycmVjdGVkQnJvd3NlcnNBbmRTb3VyY2VzLnNvdXJjZXM7XG5cbiAgICBjb25zdCBydW5uZXIgPSBvcHRzLmxpdmUgPyB0ZXN0Q2FmZS5jcmVhdGVMaXZlTW9kZVJ1bm5lcigpIDogdGVzdENhZmUuY3JlYXRlUnVubmVyKCk7XG5cbiAgICBsZXQgZmFpbGVkID0gMDtcblxuICAgIHJ1bm5lci5pc0NsaSA9IHRydWU7XG5cbiAgICBydW5uZXJcbiAgICAgICAgLnVzZVByb3h5KHByb3h5LCBwcm94eUJ5cGFzcylcbiAgICAgICAgLnNyYyhzb3VyY2VzKVxuICAgICAgICAudHNDb25maWdQYXRoKGFyZ1BhcnNlci5vcHRzLnRzQ29uZmlnUGF0aClcbiAgICAgICAgLmJyb3dzZXJzKGJyb3dzZXJzKVxuICAgICAgICAucmVwb3J0ZXIoYXJnUGFyc2VyLm9wdHMucmVwb3J0ZXIpXG4gICAgICAgIC5jb25jdXJyZW5jeShhcmdQYXJzZXIub3B0cy5jb25jdXJyZW5jeSlcbiAgICAgICAgLmZpbHRlcihhcmdQYXJzZXIuZmlsdGVyKVxuICAgICAgICAudmlkZW8ob3B0cy52aWRlbywgb3B0cy52aWRlb09wdGlvbnMsIG9wdHMudmlkZW9FbmNvZGluZ09wdGlvbnMpXG4gICAgICAgIC5zY3JlZW5zaG90cyhvcHRzLnNjcmVlbnNob3RzLCBvcHRzLnNjcmVlbnNob3RzT25GYWlscywgb3B0cy5zY3JlZW5zaG90UGF0aFBhdHRlcm4pXG4gICAgICAgIC5zdGFydEFwcChvcHRzLmFwcCwgb3B0cy5hcHBJbml0RGVsYXkpXG4gICAgICAgIC5jbGllbnRTY3JpcHRzKGFyZ1BhcnNlci5vcHRzLmNsaWVudFNjcmlwdHMpO1xuXG4gICAgcnVubmVyLm9uY2UoJ2RvbmUtYm9vdHN0cmFwcGluZycsICgpID0+IGxvZy5oaWRlU3Bpbm5lcigpKTtcblxuICAgIHRyeSB7XG4gICAgICAgIGZhaWxlZCA9IGF3YWl0IHJ1bm5lci5ydW4ob3B0cyk7XG5cbiAgICAgICAgaWYgKHNob3VsZFNob3dNYXJrZXRpbmdNZXNzYWdlKHJ1bm5lci5yZXBvcnRlclBsdWdpbmdzKSlcbiAgICAgICAgICAgIGF3YWl0IG1hcmtldGluZy5zaG93TWVzc2FnZVdpdGhMaW5rVG9UZXN0Q2FmZVN0dWRpbygpO1xuICAgIH1cblxuICAgIGZpbmFsbHkge1xuICAgICAgICBzaG93TWVzc2FnZU9uRXhpdCA9IGZhbHNlO1xuICAgICAgICBhd2FpdCB0ZXN0Q2FmZS5jbG9zZSgpO1xuICAgIH1cblxuICAgIGV4aXQoZmFpbGVkKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gbGlzdEJyb3dzZXJzIChwcm92aWRlck5hbWUgPSAnbG9jYWxseS1pbnN0YWxsZWQnKSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBicm93c2VyUHJvdmlkZXJQb29sLmdldFByb3ZpZGVyKHByb3ZpZGVyTmFtZSk7XG5cbiAgICBpZiAoIXByb3ZpZGVyKVxuICAgICAgICB0aHJvdyBuZXcgR2VuZXJhbEVycm9yKFJVTlRJTUVfRVJST1JTLmJyb3dzZXJQcm92aWRlck5vdEZvdW5kLCBwcm92aWRlck5hbWUpO1xuXG4gICAgaWYgKHByb3ZpZGVyLmlzTXVsdGlCcm93c2VyKSB7XG4gICAgICAgIGNvbnN0IGJyb3dzZXJOYW1lcyA9IGF3YWl0IHByb3ZpZGVyLmdldEJyb3dzZXJMaXN0KCk7XG5cbiAgICAgICAgYXdhaXQgYnJvd3NlclByb3ZpZGVyUG9vbC5kaXNwb3NlKCk7XG5cbiAgICAgICAgaWYgKHByb3ZpZGVyTmFtZSA9PT0gJ2xvY2FsbHktaW5zdGFsbGVkJylcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGJyb3dzZXJOYW1lcy5qb2luKCdcXG4nKSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGJyb3dzZXJOYW1lcy5tYXAoYnJvd3Nlck5hbWUgPT4gYFwiJHtwcm92aWRlck5hbWV9OiR7YnJvd3Nlck5hbWV9XCJgKS5qb2luKCdcXG4nKSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgICAgY29uc29sZS5sb2coYFwiJHtwcm92aWRlck5hbWV9XCJgKTtcblxuICAgIGV4aXQoMCk7XG59XG5cbihhc3luYyBmdW5jdGlvbiBjbGkgKCkge1xuICAgIGNvbnN0IHRlcm1pbmF0aW9uSGFuZGxlciA9IG5ldyBUZXJtaW5hdGlvbkhhbmRsZXIoKTtcblxuICAgIHRlcm1pbmF0aW9uSGFuZGxlci5vbihUZXJtaW5hdGlvbkhhbmRsZXIuVEVSTUlOQVRJT05fTEVWRUxfSU5DUkVBU0VEX0VWRU5ULCBleGl0SGFuZGxlcik7XG5cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBhcmdQYXJzZXIgPSBuZXcgQ2xpQXJndW1lbnRQYXJzZXIoKTtcblxuICAgICAgICBhd2FpdCBhcmdQYXJzZXIucGFyc2UocHJvY2Vzcy5hcmd2KTtcblxuICAgICAgICBpZiAoYXJnUGFyc2VyLm9wdHMubGlzdEJyb3dzZXJzKVxuICAgICAgICAgICAgYXdhaXQgbGlzdEJyb3dzZXJzKGFyZ1BhcnNlci5vcHRzLnByb3ZpZGVyTmFtZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGF3YWl0IHJ1blRlc3RzKGFyZ1BhcnNlcik7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgc2hvd01lc3NhZ2VPbkV4aXQgPSBmYWxzZTtcbiAgICAgICAgZXJyb3IoZXJyKTtcbiAgICB9XG59KSgpO1xuXG4iXX0=